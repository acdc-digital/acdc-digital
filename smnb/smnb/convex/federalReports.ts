// FEDERAL REPORTS RSS FEED INTEGRATION
// /Users/matthewsimon/Projects/acdc-digital/smnb/smnb/convex/federalReports.ts

"use node";
import { action, internalAction } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";
import Parser from 'rss-parser';
import Anthropic from "@anthropic-ai/sdk";

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

// RSS feed URLs for federal sources
const FEED_URLS = {
  sec: "https://www.sec.gov/cgi-bin/browse-edgar?action=getcurrent&output=atom",
  treasury: "https://home.treasury.gov/news/press-releases/rss",
  fed: "https://www.federalreserve.gov/feeds/press_all.xml",
  fomc: "https://www.federalreserve.gov/json/ne-press.json", // FOMC uses JSON
};

// Color coding for each source
const SOURCE_COLORS = {
  sec: "#2563eb", // Blue
  treasury: "#059669", // Emerald
  fed: "#7c3aed", // Purple
  fomc: "#dc2626", // Red
};

// Event type mapping
const EVENT_TYPE_MAP = {
  sec: "sec_report" as const,
  treasury: "treasury_report" as const,
  fed: "fed_report" as const,
  fomc: "fed_report" as const,
};

// Generate AI summary for a report (tweet-style, concise)
async function generateAISummary(title: string, content: string): Promise<string> {
  try {
    const prompt = `You are a financial analyst. Summarize this federal report in a brief, tweet-style commentary (max 280 characters). Be concise, analytical, and professional.

Report Title: ${title}

Report Content: ${content.slice(0, 1000)}

Provide ONLY the summary, no other text:`;

    const message = await anthropic.messages.create({
      model: "claude-3-5-haiku-20241022",
      max_tokens: 150,
      temperature: 0.7,
      messages: [{
        role: "user",
        content: prompt
      }]
    });

    const summary = message.content[0].type === "text" 
      ? message.content[0].text.trim() 
      : "";
    
    return summary || title.slice(0, 280);
  } catch (error) {
    console.error("AI summarization failed:", error);
    // Fallback to truncated title
    return title.slice(0, 280);
  }
}

// Main fetch function as internal action
const fetchFederalReportsHandler = async (
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ctx: any,
  args: {
    source: "sec" | "treasury" | "fed" | "fomc";
    limit?: number;
  }
): Promise<{
  success: boolean;
  count: number;
  errors?: string[];
}> => {
  const limit = args.limit || 10;
  const errors: string[] = [];
  
  try {
    console.log(`üì∞ Fetching ${args.source} reports...`);
    
    let reports: Array<{
      title: string;
      description: string;
      publishDate: number;
      sourceUrl: string;
    }> = [];

    // Parse RSS feed based on source
    if (args.source === "fomc") {
      // FOMC uses JSON format
      const response = await fetch(FEED_URLS.fomc);
      const data = await response.json() as { press?: Array<{ title?: string; abstract?: string; date: string; link: string }> };
      
      reports = (data.press || []).slice(0, limit).map((item) => ({
        title: item.title || "FOMC Press Release",
        description: item.abstract || "",
        publishDate: new Date(item.date).getTime(),
        sourceUrl: `https://www.federalreserve.gov${item.link}`,
      }));
    } else {
      // Use RSS parser for other sources
      const parser = new Parser({
        timeout: 10000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; SMNBBot/1.0)',
        },
      });
      
      const feed = await parser.parseURL(FEED_URLS[args.source]);
      
      reports = feed.items.slice(0, limit).map(item => ({
        title: item.title || "Untitled Report",
        description: item.contentSnippet || item.content || item.summary || "",
        publishDate: new Date(item.pubDate || item.isoDate || Date.now()).getTime(),
        sourceUrl: item.link || "",
      }));
    }

    console.log(`üìä Found ${reports.length} ${args.source} reports`);

    // Process each report with AI summarization
    let successCount = 0;
    for (const report of reports) {
      try {
        // Generate AI summary
        const aiSummary = await generateAISummary(
          report.title,
          report.description
        );

        // Create calendar event
        await ctx.runMutation(internal.calendar.createFederalReportEvent, {
          title: `[${args.source.toUpperCase()}] ${report.title}`,
          description: aiSummary,
          startTime: report.publishDate,
          endTime: report.publishDate + (24 * 60 * 60 * 1000), // 24 hours
          color: SOURCE_COLORS[args.source],
          allDay: true,
          sourceUrl: report.sourceUrl,
          eventType: EVENT_TYPE_MAP[args.source],
          metadata: JSON.stringify({
            autoGenerated: true,
            source: args.source,
            originalDescription: report.description.slice(0, 500),
            fetchedAt: Date.now(),
          }),
        });

        successCount++;
      } catch (error) {
        const errorMsg = `Failed to process report: ${report.title}`;
        console.error(errorMsg, error);
        errors.push(errorMsg);
      }
    }

    console.log(`‚úÖ Successfully created ${successCount} calendar events for ${args.source}`);

    return {
      success: successCount > 0,
      count: successCount,
      errors: errors.length > 0 ? errors : undefined,
    };
  } catch (error) {
    console.error(`‚ùå Failed to fetch ${args.source} reports:`, error);
    return {
      success: false,
      count: 0,
      errors: [String(error)],
    };
  }
};

// Internal action version
export const fetchFederalReportsInternal = internalAction({
  args: {
    source: v.union(
      v.literal("sec"),
      v.literal("treasury"),
      v.literal("fed"),
      v.literal("fomc")
    ),
    limit: v.optional(v.number()),
  },
  returns: v.object({
    success: v.boolean(),
    count: v.number(),
    errors: v.optional(v.array(v.string())),
  }),
  handler: fetchFederalReportsHandler,
});

// Public action wrapper
export const fetchFederalReports = action({
  args: {
    source: v.union(
      v.literal("sec"),
      v.literal("treasury"),
      v.literal("fed"),
      v.literal("fomc")
    ),
    limit: v.optional(v.number()), // How many reports to fetch (default: 10)
  },
  returns: v.object({
    success: v.boolean(),
    count: v.number(),
    errors: v.optional(v.array(v.string())),
  }),
  handler: async (ctx, args) => {
    const limit = args.limit || 10;
    const errors: string[] = [];
    
    try {
      console.log(`üì∞ Fetching ${args.source} reports...`);
      
      let reports: Array<{
        title: string;
        description: string;
        publishDate: number;
        sourceUrl: string;
      }> = [];

      // Parse RSS feed based on source
      if (args.source === "fomc") {
        // FOMC uses JSON format
        const response = await fetch(FEED_URLS.fomc);
        const data = await response.json() as { press?: Array<{ title?: string; abstract?: string; date: string; link: string }> };
        
        reports = (data.press || []).slice(0, limit).map((item) => ({
          title: item.title || "FOMC Press Release",
          description: item.abstract || "",
          publishDate: new Date(item.date).getTime(),
          sourceUrl: `https://www.federalreserve.gov${item.link}`,
        }));
      } else {
        // Use RSS parser for other sources
        const parser = new Parser({
          timeout: 10000,
          headers: {
            'User-Agent': 'Mozilla/5.0 (compatible; SMNBBot/1.0)',
          },
        });
        
        const feed = await parser.parseURL(FEED_URLS[args.source]);
        
        reports = feed.items.slice(0, limit).map(item => ({
          title: item.title || "Untitled Report",
          description: item.contentSnippet || item.content || item.summary || "",
          publishDate: new Date(item.pubDate || item.isoDate || Date.now()).getTime(),
          sourceUrl: item.link || "",
        }));
      }

      console.log(`üìä Found ${reports.length} ${args.source} reports`);

      // Process each report with AI summarization
      let successCount = 0;
      for (const report of reports) {
        try {
          // Generate AI summary
          const aiSummary = await generateAISummary(
            report.title,
            report.description
          );

          // Create calendar event
          await ctx.runMutation(internal.calendar.createFederalReportEvent, {
            title: `[${args.source.toUpperCase()}] ${report.title}`,
            description: aiSummary,
            startTime: report.publishDate,
            endTime: report.publishDate + (24 * 60 * 60 * 1000), // 24 hours
            color: SOURCE_COLORS[args.source],
            allDay: true,
            sourceUrl: report.sourceUrl,
            eventType: EVENT_TYPE_MAP[args.source],
            metadata: JSON.stringify({
              autoGenerated: true,
              source: args.source,
              originalDescription: report.description.slice(0, 500),
              fetchedAt: Date.now(),
            }),
          });

          successCount++;
        } catch (error) {
          const errorMsg = `Failed to process report: ${report.title}`;
          console.error(errorMsg, error);
          errors.push(errorMsg);
        }
      }

      console.log(`‚úÖ Successfully created ${successCount} calendar events for ${args.source}`);

      return {
        success: successCount > 0,
        count: successCount,
        errors: errors.length > 0 ? errors : undefined,
      };
    } catch (error) {
      console.error(`‚ùå Failed to fetch ${args.source} reports:`, error);
      return {
        success: false,
        count: 0,
        errors: [String(error)],
      };
    }
  },
});

// Shared sync logic
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function syncAllFederalReportsLogic(ctx: any): Promise<{
  success: boolean;
  results: { sec: number; treasury: number; fed: number; fomc: number };
  totalCount: number;
}> {
  console.log("üîÑ Starting daily federal reports sync...");
  
  const results = {
    sec: 0,
    treasury: 0,
    fed: 0,
    fomc: 0,
  };

  // Fetch from all sources sequentially
  const sources: Array<"sec" | "treasury" | "fed" | "fomc"> = ["sec", "treasury", "fed", "fomc"];
  
  for (const source of sources) {
    try {
      // Call the internal fetch action
      const result = await ctx.runAction(internal.federalReports.fetchFederalReportsInternal, {
        source,
        limit: 10,
      });
      
      results[source] = result.count;
    } catch (error) {
      console.error(`Failed to sync ${source}:`, error);
      results[source] = 0;
    }
  }

  const totalCount = Object.values(results).reduce((sum, count) => sum + count, 0);
  
  console.log(`‚úÖ Daily sync complete: ${totalCount} total events created`);
  console.log(`   SEC: ${results.sec}, Treasury: ${results.treasury}, Fed: ${results.fed}, FOMC: ${results.fomc}`);

  return {
    success: totalCount > 0,
    results,
    totalCount,
  };
}

// Internal action that does the actual syncing
export const syncAllFederalReportsInternal = internalAction({
  args: {},
  returns: v.object({
    success: v.boolean(),
    results: v.object({
      sec: v.number(),
      treasury: v.number(),
      fed: v.number(),
      fomc: v.number(),
    }),
    totalCount: v.number(),
  }),
  handler: syncAllFederalReportsLogic,
});

// Public action wrapper that calls the internal action
export const syncAllFederalReports = action({
  args: {},
  returns: v.object({
    success: v.boolean(),
    results: v.object({
      sec: v.number(),
      treasury: v.number(),
      fed: v.number(),
      fomc: v.number(),
    }),
    totalCount: v.number(),
  }),
  handler: async (ctx): Promise<{
    success: boolean;
    results: {
      sec: number;
      treasury: number;
      fed: number;
      fomc: number;
    };
    totalCount: number;
  }> => {
    return await ctx.runAction(internal.federalReports.syncAllFederalReportsInternal, {});
  },
});

// Scheduled sync action (called by cron job)
export const scheduledSync = internalAction({
  args: {},
  returns: v.null(),
  handler: async (ctx) => {
    console.log("‚è∞ Scheduled federal reports sync triggered");
    
    try {
      await ctx.runAction(internal.federalReports.syncAllFederalReportsInternal, {});
    } catch (error) {
      console.error("‚ùå Scheduled sync failed:", error);
    }
    
    return null;
  },
});
